---
// -----------------------------------------------------------------
// 这是侧边栏的“总指挥”文件。
// 它的工作方式是：读取 config.ts 中的侧边栏配置，
// 然后根据配置中的 type 名称，在这个文件的 "componentMap" 中找到对应的组件并渲染它。
// -----------------------------------------------------------------

import type { MarkdownHeading } from "astro";
import type { WidgetComponentConfig } from "../../types/config";
import { widgetManager } from "../../utils/widget-manager";

// 导入所有可能在侧边栏中使用的小部件组件
import Announcement from "./Announcement.astro";
import Categories from "./Categories.astro";
import MusicPlayer from "./MusicPlayer.svelte";
import Profile from "./Profile.astro";
import Statistics from "./Statistics.astro";
import Tags from "./Tags.astro";
import TOC from "./TOC.astro";
// 导入我们之前创建的 VisitCounter 组件
import VisitCounter from './VisitCounter.astro'; 

interface Props {
    class?: string;
    headings?: MarkdownHeading[];
}

const { class: className, headings } = Astro.props;

// 从 widgetManager 获取已配置好的、需要显示在不同位置的组件列表
const topComponents = widgetManager.getComponentsByPosition("top");
const stickyComponents = widgetManager.getComponentsByPosition("sticky");

// -----------------------------------------------------------------
// 【核心】组件的“地图”，它建立了配置中的 type 名称与实际组件文件之间的对应关系。
// -----------------------------------------------------------------
const componentMap = {
    profile: Profile,
    announcement: Announcement,
    categories: Categories,
    tags: Tags,
    toc: TOC,
    "music-player": MusicPlayer,
    statistics: Statistics,
    // --- 【关键修正】在这里添加下面这一行 ---
    // 我们将 config.ts 中定义的 "visit-counter" 类型
    // 与我们实际创建的 VisitCounter.astro 组件文件关联起来。
    "visit-counter": VisitCounter,
};

// 渲染组件的辅助函数，它会根据传入的配置在 componentMap 中查找并准备渲染
function renderComponent(
    component: WidgetComponentConfig,
    index: number,
    _components: WidgetComponentConfig[],
) {
    // 在地图中查找组件
    const ComponentToRender =
        componentMap[component.type as keyof typeof componentMap];
    
    // 如果在地图中找不到对应的组件，则不渲染任何东西
    if (!ComponentToRender) return null;

    // 获取组件的 CSS 类名和样式
    const componentClass = widgetManager.getComponentClass(component, index);
    const componentStyle = widgetManager.getComponentStyle(component, index);

    // 返回要渲染的组件及其所有需要的属性 (props)
    return {
        Component: ComponentToRender,
        props: {
            class: componentClass,
            style: componentStyle,
            // 特殊处理：如果组件是 TOC，则传递 headings 属性
            headings: component.type === "toc" ? headings : undefined,
            ...component.customProps,
        },
    };
}
---

<!-- 
    下面的 HTML 模板和脚本部分完全保持您原有文件的样子。
    它现在可以自动根据我们更新后的 componentMap 来正确渲染 "visit-counter" 组件了。
-->
<div id="sidebar" class:list={[className, "w-full"]}>
    <!-- 顶部固定组件区域 -->
    {topComponents.length > 0 && (
        <div class="flex flex-col w-full gap-4 mb-4">
            {topComponents.map((component, index) => {
                const renderData = renderComponent(component, index, topComponents);
                if (!renderData) return null;
                
                const { Component, props } = renderData;
                return <Component {...props} />;
            })}
        </div>
    )}
    
    <!-- 粘性 (可随页面滚动固定的) 组件区域 -->
    {stickyComponents.length > 0 && (
        <div id="sidebar-sticky" class="transition-all duration-700 flex flex-col w-full gap-4 top-4 sticky top-4">
            {stickyComponents.map((component, index) => {
                const renderData = renderComponent(component, index, stickyComponents);
                if (!renderData) return null;
                
                const { Component, props } = renderData;
                return <Component {...props} />;
            })}
        </div>
    )}
</div>

<!-- 响应式样式和JavaScript (保持不变) -->
<style>
    /* 响应式断点样式 */
    @media (max-width: 768px) {
        #sidebar {
            display: var(--sidebar-mobile-display, block);
        }
    }
    
    @media (min-width: 769px) and (max-width: 1024px) {
        #sidebar {
            display: var(--sidebar-tablet-display, block);
        }
    }
    
    @media (min-width: 1025px) {
        #sidebar {
            display: var(--sidebar-desktop-display, block);
        }
    }
</style>

<script is:inline>
    // @ts-nocheck
    import { widgetManager } from "../../utils/widget-manager";
    
    // 响应式布局管理
    class SidebarManager {
        constructor() {
            this.init();
        }
        
        init() {
            this.updateResponsiveDisplay();
            window.addEventListener('resize', () => this.updateResponsiveDisplay());
            
            // 监听SWUP内容替换事件
            if (typeof window !== 'undefined' && window.swup) {
                window.swup.hooks.on('content:replace', () => {
                    // 延迟执行以确保DOM已更新
                    setTimeout(() => {
                        this.updateResponsiveDisplay();
                    }, 100);
                });
            }
        }
        
        updateResponsiveDisplay() {
            const breakpoints = widgetManager.getBreakpoints();
            const width = window.innerWidth;
            
            let deviceType;
            if (width < breakpoints.mobile) {
                deviceType = 'mobile';
            } else if (width < breakpoints.tablet) {
                deviceType = 'tablet';
            } else {
                deviceType = 'desktop';
            }
            
            const shouldShow = widgetManager.shouldShowSidebar(deviceType);
            const sidebar = document.getElementById('sidebar');
            
            if (sidebar) {
                sidebar.style.setProperty(
                    `--sidebar-${deviceType}-display`, 
                    shouldShow ? 'block' : 'none'
                );
            }
        }
    }
    
    // 初始化侧边栏管理器
    new SidebarManager();
</script>

